-- Required modules
local utils = require 'mp.utils'
local msg = require 'mp.msg'
local json = require 'mp.utils'.parse_json -- Utilize mpv's built-in JSON parser
local mp = require 'mp'

-- #########################################################################
-- # Configuration Variables                                                #
-- #########################################################################

-- Ensure these paths are correct for your system
local FFMPEG_PATH = "./ffmpeg-7.1.1-full_build/bin/ffmpeg.exe"
local WHISPER_CMD = "./Whisper/Release/whisper-cli.exe"
local WHISPER_MODEL = "./ggml-large-v3-turbo.bin"
local VAD_SCRIPT = ".VAD/vad_script.py" -- Path to your Python VAD script
local PYTHON_EXECUTABLE = "python" -- Or the full path to your python.exe if not in PATH
local TMP_DIR = "./temp" -- Ensure this directory exists and MPV can write to it

-- Temporary file paths
local TMP_WAV_PATH = utils.join_path(TMP_DIR, "mpv_whisper_live_tmp.wav") -- For the whole chunk
local MAIN_SRT_PATH = utils.join_path(TMP_DIR, "mpv_whisper_main_subs.srt")
local VAD_SEGMENTS_JSON_PATH = utils.join_path(TMP_DIR, "vad_segments.json")
local LOG_FILE_PATH = utils.join_path(TMP_DIR, "mpv_whisper_log.txt")

-- Transcription settings
local LANGUAGE = "en" -- Language for Whisper
local THREADS = 8     -- Number of threads for Whisper
local CHUNK_INTERVAL = 60 -- Process audio in chunks of this many seconds
local MIN_SEGMENT_DURATION_MS = 250 -- Minimum duration for a VAD segment before padding (Whisper needs > ~0.1s) - Lowered slightly
local SHORT_SEGMENT_PADDING_MS = 500    -- Pad *short* VAD segments to this duration - Lowered slightly
local VAD_SPEECH_PAD_MS = 300      -- *** ADDED: Padding for VAD speech start/end (ms) ***
local VAD_MIN_SILENCE_MS = 150     -- *** ADDED: Minimum silence duration for VAD (ms) ***
local VAD_MIN_SPEECH_MS = 150      -- *** ADDED: Minimum speech duration for VAD (ms) ***
local ENABLE_WORD_TIMESTAMPS = false -- Keep false to avoid crashes

-- #########################################################################
-- # Global Variables                                                      #
-- #########################################################################

local running = false           -- Is the main captioning process active?
local loopRunning = false       -- Flag to prevent multiple loops
local processing_chunk = false  -- Are we currently processing a specific chunk (extract/VAD/transcribe)?
local VAD_running = false       -- Is the VAD script currently executing?
local processing_segments = false -- Are we currently transcribing VAD segments?
local next_chunk_timer = nil    -- *** ADDED: Timer handle for the next chunk processing ***
local segment_timer = nil       -- *** ADDED: Timer handle for segment processing ***
local seek_pending = false      -- *** ADDED: Flag to indicate a seek is being processed ***

-- #########################################################################
-- # Utility Functions                                                     #
-- #########################################################################

-- Function to log messages to a file and mpv console
local function logMessage(level, message)
    -- Log to file
    local file = io.open(LOG_FILE_PATH, "a")
    if file then
        local timestamp = os.date("[%Y-%m-%d %H:%M:%S]")
        file:write(timestamp .. " [" .. level .. "] " .. message .. "\n")
        file:close()
    end
    -- Log to mpv console (use different levels)
    if level == 'error' then
        msg.error("[WhisperLive] " .. message)
    elseif level == 'warn' then
        msg.warn("[WhisperLive] " .. message)
    else -- info, debug etc.
        msg.info("[WhisperLive] " .. message)
    end
end

-- Function to run external commands safely
local function runCommand(executable, args_table, description, callback)
    local command_args = { executable }
    for _, arg in ipairs(args_table) do
        table.insert(command_args, arg)
    end

    local command_str = table.concat(command_args, ' ')
    logMessage("info", "Executing (" .. description .. "): " .. command_str)

    local res = utils.subprocess({
        args = command_args,
        cancellable = false, -- Keep false, interruption logic handled elsewhere
        max_size = 20 * 1024 * 1024,
        capture_stdout = true,
        capture_stderr = true,
        playback_only = false,
    })

    -- Log outputs
    if res.stdout and res.stdout ~= "" then
        logMessage('debug', description .. ' Output (stdout): ' .. res.stdout)
    end
    if res.stderr and res.stderr ~= "" then
        local level = 'warn'
        if description:match("FFmpeg") or description:match("Whisper") then
             if res.stderr:match("frame=") or res.stderr:match("size=") or res.stderr:match("whisper_print_progress_callback") or res.stderr:match("whisper_print_segment_callback") then
                 level = 'debug'
             end
             if res.stderr:match("error: unknown argument: --no%-colors") then
                 level = 'debug'
                 logMessage(level, description .. ' Output (stderr - Known Issue Ignored): ' .. res.stderr)
             else
                logMessage(level, description .. ' Output (stderr): ' .. res.stderr)
             end
        else
             logMessage(level, description .. ' Output (stderr): ' .. res.stderr)
        end
    end

    -- *** MODIFICATION START: Check 'running' flag before calling callback ***
    if not running and not seek_pending then
         logMessage('info', description .. ' Process finished but captioning was stopped/seeked. Ignoring result.')
         if callback then callback(nil, false, "Process interrupted by stop/seek") end
         return
    end
    -- *** MODIFICATION END ***

    if res.error then
        logMessage('error', description .. ' Command Error: ' .. res.error)
        if callback then callback(nil, false, res.error) end
    -- Allow negative exit codes like -1073741515 as potential crashes but log as error
    elseif res.status ~= 0 then
        logMessage('error', description .. ' Command failed with status: ' .. tostring(res.status))
        if callback then callback(res.stdout or "", false, "Exit status: " .. tostring(res.status)) end
    else
        logMessage('info', description .. ' Command exited successfully (status: ' .. tostring(res.status) .. ')')
        if callback then callback(res.stdout or "", true, nil) end
    end
end

-- Function to safely delete a file
local function safeRemove(filepath, description)
    local file_info = utils.file_info(filepath)
    if file_info then
        local success, err = os.remove(filepath)
        if success then
            logMessage("debug", "Cleaned up temporary file (" .. description .. "): " .. filepath)
        else
            logMessage("warn", "Failed to remove temporary file (" .. description .. "): " .. filepath .. " - Error: " .. (err or "unknown"))
        end
    else
         logMessage("debug", "Temporary file (".. description ..") not found, skipping removal: " .. filepath)
    end
end

-- #########################################################################
-- # Core Logic Functions                                                  #
-- #########################################################################

-- Function to adjust timestamps in the SRT file content (Line-by-line processing)
local function adjustTimestamps(srt_content, time_offset_ms)
    if not srt_content or srt_content == "" then
        logMessage("warn", "adjustTimestamps called with empty or nil content.")
        return ""
    end

    -- logMessage("debug", "Raw SRT content received by adjustTimestamps:\n---\n" .. srt_content .. "\n---") -- Less verbose logging

    local adjusted_lines = {}
    local timestamp_found = false

    for line in srt_content:gmatch("([^\r\n]*)") do
        line = line:match("^%s*(.-)%s*$") -- Trim leading/trailing whitespace
        local sh, sm, ss, sms, eh, em, es, ems = line:match("^(%d%d):(%d%d):(%d%d)%s*,%s*(%d%d%d)%s*-->%s*(%d%d):(%d%d):(%d%d)%s*,%s*(%d%d%d)$")

        if sh then
            timestamp_found = true
            -- logMessage("debug", "Timestamp line matched: [" .. line .. "]")
            -- logMessage("debug", string.format("Captured values: sh=%s, sm=%s, ss=%s, sms=%s, eh=%s, em=%s, es=%s, ems=%s",
            --     tostring(sh), tostring(sm), tostring(ss), tostring(sms), tostring(eh), tostring(em), tostring(es), tostring(ems)))

            local conversion_success, result_line = pcall(function()
                local n_sh = tonumber(sh); local n_sm = tonumber(sm); local n_ss = tonumber(ss); local n_sms = tonumber(sms)
                local n_eh = tonumber(eh); local n_em = tonumber(em); local n_es = tonumber(es); local n_ems = tonumber(ems)

                if not (n_sh and n_sm and n_ss and n_sms and n_eh and n_em and n_es and n_ems) then
                    logMessage("error", "Timestamp tonumber conversion resulted in nil value.")
                    error("Timestamp tonumber conversion resulted in nil value.")
                end

                local start_total_ms = (n_sh * 3600 + n_sm * 60 + n_ss) * 1000 + n_sms
                local end_total_ms = (n_eh * 3600 + n_em * 60 + n_es) * 1000 + n_ems

                local adjusted_start_ms = start_total_ms + time_offset_ms
                local adjusted_end_ms = end_total_ms + time_offset_ms
                adjusted_start_ms = math.max(0, adjusted_start_ms)
                adjusted_end_ms = math.max(adjusted_start_ms, adjusted_end_ms)

                local adj_sh = math.floor(adjusted_start_ms / (3600 * 1000))
                local rem_ms = adjusted_start_ms % (3600 * 1000)
                local adj_sm = math.floor(rem_ms / (60 * 1000))
                rem_ms = rem_ms % (60 * 1000)
                local adj_ss = math.floor(rem_ms / 1000)
                local adj_sms = rem_ms % 1000

                local adj_eh = math.floor(adjusted_end_ms / (3600 * 1000))
                rem_ms = adjusted_end_ms % (3600 * 1000)
                local adj_em = math.floor(rem_ms / (60 * 1000))
                rem_ms = rem_ms % (60 * 1000)
                local adj_es = math.floor(rem_ms / 1000)
                local adj_ems = rem_ms % 1000

                return string.format("%02d:%02d:%02d,%03d --> %02d:%02d:%02d,%03d",
                                     adj_sh, adj_sm, adj_ss, adj_sms,
                                     adj_eh, adj_em, adj_es, adj_ems)
            end)

            if conversion_success then
                table.insert(adjusted_lines, result_line)
            else
                logMessage("error", "Error during timestamp calculation: " .. tostring(result_line) .. ". Original line: [" .. line .. "]")
                table.insert(adjusted_lines, line) -- Keep original on error
            end
        else
            -- Keep non-timestamp lines (like index numbers and text)
            if line ~= "" then
                table.insert(adjusted_lines, line)
            end
        end
    end

    if not timestamp_found then
        logMessage("warn", "No timestamp lines matched the pattern in adjustTimestamps.")
    end

    local final_content = table.concat(adjusted_lines, "\n")
    -- logMessage("debug", "Adjusted SRT content (reconstructed):\n---\n" .. final_content .. "\n---") -- Less verbose logging
    return final_content
end

-- Function to append adjusted SRT content to the main SRT file and renumber subtitles
local function appendToMainSRT(srt_adjusted_content)
    if not srt_adjusted_content or srt_adjusted_content == "" then
        logMessage("info", "No adjusted SRT content to append.")
        return false
    end

    -- *** ADDED: Check if running before appending ***
    if not running then
        logMessage("info", "Skipping appendToMainSRT because captioning is stopped.")
        return false
    end

    -- Read existing main SRT content to find the last index
    local main_content = ""
    local last_index = 0
    local main_srt_file_read = io.open(MAIN_SRT_PATH, "r")
    if main_srt_file_read then
        main_content = main_srt_file_read:read("*all")
        main_srt_file_read:close()
        -- Find the last subtitle index in the existing content
        for index in main_content:gmatch("\n(%d+)\n%d%d:%d%d:%d%d,%d%d%d%s*-->") do
            last_index = math.max(last_index, tonumber(index) or 0) -- Ensure tonumber doesn't fail on weird input
        end
         if last_index == 0 then -- Check if the first entry doesn't have a preceding newline
             for index in main_content:gmatch("^(%d+)\n%d%d:%d%d:%d%d,%d%d%d%s*-->") do
                 last_index = math.max(last_index, tonumber(index) or 0)
             end
         end
        logMessage("debug", "Last index found in main SRT: " .. last_index)
    else
        logMessage("info", "Main SRT file does not exist or is empty. Starting fresh.")
    end

    -- Renumber the new content before appending
    local current_new_index = 0
    local renumbered_new_content = srt_adjusted_content:gsub("\n(%d+)\n(%d%d:%d%d:%d%d,%d%d%d%s*-->%s*%d%d:%d%d:%d%d,%d%d%d)",
        function(num, timestamp_line)
            current_new_index = current_new_index + 1
            return "\n" .. (last_index + current_new_index) .. "\n" .. timestamp_line
        end)
    -- Handle the case where the new SRT starts with index 1 without a preceding newline
    if not renumbered_new_content:match("^\n") and srt_adjusted_content:match("^(%d+)\n(%d%d:%d%d:%d%d,%d%d%d%s*-->%s*%d%d:%d%d:%d%d,%d%d%d)") then
         renumbered_new_content = srt_adjusted_content:gsub("^(%d+)\n(%d%d:%d%d:%d%d,%d%d%d%s*-->%s*%d%d:%d%d:%d%d,%d%d%d)",
            function(num, timestamp_line)
                current_new_index = current_new_index + 1
                -- No prefix needed when appending, just the new index line
                return (last_index + current_new_index) .. "\n" .. timestamp_line
            end, 1) -- Only replace the first occurrence
    end

    -- Open the main SRT file in append mode
    local main_srt_file_append = io.open(MAIN_SRT_PATH, "a")
    if not main_srt_file_append then
        logMessage("error", "Failed to open main SRT file for appending: " .. MAIN_SRT_PATH)
        return false
    end

    -- Add a newline separator if the file wasn't empty and doesn't end with one
    local separator = ""
    if main_content ~= "" and not main_content:match("[\r\n]$") then
         separator = "\n"
    end

    -- Append the renumbered content
    main_srt_file_append:write(separator .. renumbered_new_content .. "\n") -- Ensure trailing newline
    main_srt_file_append:close()
    logMessage("info", "Appended and renumbered subtitles to main subtitle file: " .. MAIN_SRT_PATH)

    -- Refresh Subtitles
    logMessage("debug", "Attempting to refresh subtitle file: " .. MAIN_SRT_PATH)
    local file_info = utils.file_info(MAIN_SRT_PATH)
    if not file_info or not file_info.size or file_info.size == 0 then
        logMessage("warn", "Main SRT file is empty or missing after append, cannot refresh track.")
        return false
    end

    -- Use 'rescan' to update the existing track instead of adding a new one each time.
    -- This requires knowing the track ID, but since we remove all tracks on start/seek
    -- and add only this one, we can try to find it.
    local track_list = mp.get_property_native("track-list")
    local main_sub_id = nil
    if track_list then
        for i = 1, #track_list do
            local track = track_list[i]
            -- Match based on filename (might be fragile if mpv changes format)
            if track.type == "sub" and track.external and track.external_filename and
               utils.file_info(track.external_filename) and utils.file_info(MAIN_SRT_PATH) and
               utils.file_info(track.external_filename).absolute_path == utils.file_info(MAIN_SRT_PATH).absolute_path then
               main_sub_id = track.id
               logMessage("debug", "Found existing main sub track ID: " .. main_sub_id)
               break
            end
        end
    end

    if main_sub_id then
        -- Try to rescan the existing track
        mp.commandv("sub_rescan", main_sub_id)
        logMessage("info", "Subtitle track rescanned (ID: " .. main_sub_id .. ")")
    else
        -- Fallback: Add it again with 'select'. This shouldn't happen often after start/seek.
        logMessage("warn", "Could not find main sub track ID to rescan. Adding again with 'select'.")
        local res = mp.commandv("sub_add", MAIN_SRT_PATH, "select")
        if type(res) == "table" and res.track_id ~= nil then
            logMessage("info", "Subtitle track added (new track ID: " .. res.track_id .. ").")
        else
            logMessage("warn", "Fallback sub_add command executed. Result: " .. utils.to_string(res))
        end
    end

    return true
end


-- Helper function to transcribe a *single* audio segment using Whisper
local function transcribeSegmentAudio(audio_segment_path, segment_start_time_in_media, callback)
    -- *** ADDED: Check if running before transcribing ***
    if not running then
        logMessage("info", "Skipping transcribeSegmentAudio because captioning is stopped.")
        callback(false) -- Indicate failure due to stop
        return
    end

    -- Define a base name for whisper output files for this segment
    local whisper_output_base = utils.join_path(TMP_DIR, string.format("mpv_whisper_segment_%d", math.floor(segment_start_time_in_media))) -- Use floor for filename safety
    local whisper_srt_path = whisper_output_base .. ".srt"

    -- Clean up potential leftover file from previous run for this time segment
    safeRemove(whisper_srt_path, "Old Whisper Segment SRT")

    local whisper_args = {
        "-m", WHISPER_MODEL,
        "-t", tostring(THREADS),
        "--language", LANGUAGE,
        "--output-srt",        -- Generate SRT file
        "--file", audio_segment_path,
        "--output-file", whisper_output_base -- Whisper appends .srt
    }
    if ENABLE_WORD_TIMESTAMPS then
        table.insert(whisper_args, "--word-timestamps")
        table.insert(whisper_args, "true")
    end

    runCommand(WHISPER_CMD, whisper_args, "Whisper Segment Transcription", function(output, success, err)
        local srt_content = nil
        local append_success = false

        local function finish_and_cleanup(final_success)
            safeRemove(whisper_srt_path, "Whisper Segment Output SRT") -- Clean up the raw whisper SRT
            callback(final_success)
        end

        -- *** ADDED: Check running flag again after command finishes ***
        if not running then
             logMessage("info", "Captioning stopped during Whisper segment transcription.")
             finish_and_cleanup(false)
             return
        end

        if not success then
            logMessage("error", "Whisper command failed for segment transcription. Status/Error: " .. tostring(err))
            finish_and_cleanup(false)
            return
        end

        local srt_file = io.open(whisper_srt_path, "r")
        if not srt_file then
            logMessage("error", "Whisper succeeded but segment SRT file not found: " .. whisper_srt_path)
            finish_and_cleanup(false)
            return
        end

        srt_content = srt_file:read("*all")
        srt_file:close()

        if not srt_content or srt_content == "" then
             logMessage("warn", "Segment SRT file was found but appears empty: " .. whisper_srt_path)
             finish_and_cleanup(true) -- Consider this a success (nothing to append)
             return
        end

        -- Adjust timestamps relative to the segment's *original* start time in the overall media
        local adjusted_srt_content = adjustTimestamps(srt_content, segment_start_time_in_media)

        if adjusted_srt_content and adjusted_srt_content ~= "" then
            -- *** ADDED: Check running flag before appending ***
            if running then
                append_success = appendToMainSRT(adjusted_srt_content)
            else
                logMessage("info", "Skipping append because captioning stopped before appendToMainSRT.")
                append_success = false -- Mark as failure due to stop
            end
        else
            logMessage("warn", "Skipping append because adjusted segment SRT content is empty or nil.")
            append_success = true -- Still considered success as there was nothing valid to append
        end

        finish_and_cleanup(append_success)
    end)
end

-- Function to transcribe a single audio segment (handles extraction and padding)
local function transcribeSegment(segment, chunk_start_time_ms, callback)
    -- *** ADDED: Check if running before processing segment ***
    if not running then
        logMessage("info", "Skipping transcribeSegment because captioning is stopped.")
        callback(false)
        return
    end

    local vad_start_rel_ms = segment.start -- Original VAD start relative to chunk
    local vad_end_rel_ms = segment["end"]   -- Original VAD end relative to chunk
    local vad_duration_ms = vad_end_rel_ms - vad_start_rel_ms
    local vad_start_abs_ms = chunk_start_time_ms + vad_start_rel_ms -- Original VAD absolute start time

    logMessage("info", string.format("Processing segment: VAD AbsStart=%d ms, VAD RelStart=%d ms, VAD RelEnd=%d ms, VAD Duration=%d ms",
                                     vad_start_abs_ms, vad_start_rel_ms, vad_end_rel_ms, vad_duration_ms))

    if vad_duration_ms <= 0 then
        logMessage("warn", "Skipping segment with zero or negative VAD duration.")
        callback(true)
        return
    end

    local base_filename = string.format("segment_%d_%d", math.floor(vad_start_abs_ms), math.floor(vad_start_abs_ms + vad_duration_ms))
    local segment_audio_path = utils.join_path(TMP_DIR, base_filename .. ".wav")

    -- Extract the *original* VAD segment using FFmpeg from the *chunk* WAV
    local extract_args = {
        "-ss", tostring(vad_start_rel_ms / 1000),
        "-t", tostring(vad_duration_ms / 1000),
        "-i", TMP_WAV_PATH,
        "-ac", "1",
        "-ar", "16000",
        "-acodec", "pcm_s16le",
        "-af", "aresample=resampler=soxr",
        "-y", segment_audio_path
    }

    runCommand(FFMPEG_PATH, extract_args, "FFmpeg Segment Extraction", function(output, success, err)
        -- *** ADDED: Check running flag again after command finishes ***
        if not running then
             logMessage("info", "Captioning stopped during FFmpeg segment extraction.")
             safeRemove(segment_audio_path, "Segment (Stopped during extraction)")
             callback(false)
             return
        end

        if not success then
            logMessage("error", "FFmpeg command for segment extraction failed.")
            callback(false)
            return
        end

        local audio_to_transcribe = segment_audio_path
        local padded_short_segment_path = ""

        if vad_duration_ms < MIN_SEGMENT_DURATION_MS then
            logMessage("info", "Original segment duration (" .. vad_duration_ms .. "ms) is less than minimum (" .. MIN_SEGMENT_DURATION_MS .. "ms). Padding for Whisper stability.")
            padded_short_segment_path = utils.join_path(TMP_DIR, string.format("padded_short_%s.wav", base_filename))
            local padding_duration_s = (SHORT_SEGMENT_PADDING_MS - vad_duration_ms) / 1000

            local pad_args = {
                "-i", segment_audio_path,
                "-af", string.format("apad=pad_dur=%f", padding_duration_s),
                "-acodec", "pcm_s16le", "-ar", "16000", "-ac", "1",
                "-y", padded_short_segment_path
            }

            runCommand(FFMPEG_PATH, pad_args, "FFmpeg Short Segment Padding", function(pad_output, pad_success, pad_err)
                 -- *** ADDED: Check running flag again after command finishes ***
                if not running then
                     logMessage("info", "Captioning stopped during FFmpeg short segment padding.")
                     safeRemove(segment_audio_path, "Original Segment (Stopped during padding)")
                     safeRemove(padded_short_segment_path, "Short Padded Segment (Stopped during padding)")
                     callback(false)
                     return
                end

                if not pad_success then
                    logMessage("error", "FFmpeg command for short segment padding failed.")
                    safeRemove(segment_audio_path, "Original Segment (Short Pad Failed)")
                    callback(false)
                    return
                end

                transcribeSegmentAudio(padded_short_segment_path, vad_start_abs_ms, function(transcribe_success)
                    safeRemove(segment_audio_path, "Original Segment")
                    safeRemove(padded_short_segment_path, "Short Padded Segment")
                    callback(transcribe_success)
                end)
            end)
        else
            transcribeSegmentAudio(audio_to_transcribe, vad_start_abs_ms, function(transcribe_success)
                safeRemove(segment_audio_path, "Original Segment")
                callback(transcribe_success)
            end)
        end
    end)
end


-- Function to run VAD script
local function runVAD(callback)
    if VAD_running then
        logMessage("warn", "VAD is already running. Skipping this invocation.")
        callback(false)
        return
    end
    -- *** ADDED: Check if running before starting VAD ***
    if not running then
        logMessage("info", "Skipping runVAD because captioning is stopped.")
        callback(false)
        return
    end

    VAD_running = true
    logMessage("info", "Running VAD on audio chunk: " .. TMP_WAV_PATH)

    local vad_args = {
        VAD_SCRIPT,
        TMP_WAV_PATH,
        TMP_DIR,
        "--speech_pad_ms", tostring(VAD_SPEECH_PAD_MS),
        "--min_silence_duration_ms", tostring(VAD_MIN_SILENCE_MS),
        "--min_speech_duration_ms", tostring(VAD_MIN_SPEECH_MS)
    }

    safeRemove(VAD_SEGMENTS_JSON_PATH, "Old VAD JSON")

    runCommand(PYTHON_EXECUTABLE, vad_args, "VAD Script", function(output, success, err)
        VAD_running = false -- Mark VAD as finished

        -- *** ADDED: Check running flag again after command finishes ***
        if not running then
             logMessage("info", "Captioning stopped during VAD execution.")
             safeRemove(VAD_SEGMENTS_JSON_PATH, "VAD JSON (Stopped during VAD)")
             callback(false)
             return
        end

        if not success then
            logMessage("error", "VAD script failed. Error: " .. (err or "Unknown"))
            callback(false)
            return
        end

        if not utils.file_info(VAD_SEGMENTS_JSON_PATH) then
            logMessage("error", "VAD script succeeded but did not generate segments file: " .. VAD_SEGMENTS_JSON_PATH)
            logMessage("warn", "VAD script stdout: " .. output)
            callback(false)
            return
        end

        logMessage("info", "VAD processing completed successfully.")
        callback(true)
    end)
end

-- Function to process segments sequentially after VAD succeeds
local function processSegments(chunk_start_time_ms, callback)
    if processing_segments then
        logMessage("warn", "Already processing segments. Skipping this invocation.")
        callback(false)
        return
    end
     -- *** ADDED: Check if running before starting segment processing ***
    if not running then
        logMessage("info", "Skipping processSegments because captioning is stopped.")
        callback(false)
        return
    end

    processing_segments = true
    logMessage("info", "Processing VAD segments for chunk starting at " .. chunk_start_time_ms .. " ms.")

    local segments_file = io.open(VAD_SEGMENTS_JSON_PATH, "r")
    if not segments_file then
        logMessage("error", "Failed to open VAD segments file: " .. VAD_SEGMENTS_JSON_PATH)
        processing_segments = false
        callback(false)
        return
    end
    local segments_content = segments_file:read("*all")
    segments_file:close()

    safeRemove(VAD_SEGMENTS_JSON_PATH, "Current VAD JSON")

    local parse_success, segments = pcall(json, segments_content)
    if not parse_success or type(segments) ~= "table" then
        logMessage("error", "Failed to parse VAD segments JSON or it's not a table. Content: " .. segments_content)
        processing_segments = false
        callback(false)
        return
    end

    if #segments == 0 then
        logMessage("info", "No voice segments detected in this chunk.")
        processing_segments = false
        callback(true)
        return
    end

    logMessage("info", "Found " .. #segments .. " segments to transcribe.")

    local segment_index = 1
    local all_segments_processed_successfully = true

    local function processNextSegment()
        -- *** MODIFIED: Clear timer handle ***
        segment_timer = nil

        -- Check if we are done or if the main process was stopped
        if not running or segment_index > #segments then
            if segment_index > #segments then
                logMessage("info", "Finished processing all segments for this chunk.")
            else
                logMessage("info", "Segment processing stopped because captioning was disabled.")
                all_segments_processed_successfully = false
            end
            processing_segments = false
            callback(all_segments_processed_successfully)
            return
        end

        local segment = segments[segment_index]
        if type(segment) ~= "table" or type(segment.start) ~= "number" or type(segment["end"]) ~= "number" then
             logMessage("warn", "Skipping invalid segment data at index " .. segment_index)
             segment_index = segment_index + 1
             -- *** MODIFIED: Schedule next segment processing using timer ***
             segment_timer = mp.add_timeout(0, processNextSegment)
             return
        end

        transcribeSegment(segment, chunk_start_time_ms, function(success)
            -- *** ADDED: Check running flag again after segment transcription finishes ***
            if not running then
                logMessage("info", "Captioning stopped during segment transcription callback.")
                all_segments_processed_successfully = false
                processing_segments = false
                callback(false) -- Signal failure due to stop
                return
            end

            if not success then
                logMessage("warn", "Failed to process segment " .. segment_index .. ". Continuing with next.")
                all_segments_processed_successfully = false
            end
            segment_index = segment_index + 1
            -- *** MODIFIED: Schedule next segment processing using timer ***
            segment_timer = mp.add_timeout(0, processNextSegment)
        end)
    end

    -- Start processing the first segment using a timer
    segment_timer = mp.add_timeout(0, processNextSegment)
end

-- Function to extract audio chunk from the media file
local function extractAudioChunk(media_path, start_ms, duration_ms, callback)
     -- *** ADDED: Check if running before extracting chunk ***
    if not running then
        logMessage("info", "Skipping extractAudioChunk because captioning is stopped.")
        callback(false)
        return
    end

    logMessage("info", string.format("Extracting audio chunk: Start=%.3f s, Duration=%.3f s", start_ms / 1000, duration_ms / 1000))
    safeRemove(TMP_WAV_PATH, "Previous Audio Chunk")
    local args = {
        "-ss", tostring(start_ms / 1000),
        "-t", tostring(duration_ms / 1000),
        "-i", media_path,
        "-map", "0:a:m:language:eng", -- Make language mapping optional
        "-ac", "1",
        "-ar", "16000",
        "-acodec", "pcm_s16le",
        "-af", "aresample=resampler=soxr",
        "-y", TMP_WAV_PATH
    }
    runCommand(FFMPEG_PATH, args, "FFmpeg Chunk Extraction", function(output, success, err)
        -- *** ADDED: Check running flag again after command finishes ***
        if not running then
             logMessage("info", "Captioning stopped during FFmpeg chunk extraction.")
             safeRemove(TMP_WAV_PATH, "Audio Chunk (Stopped during extraction)")
             callback(false)
             return
        end

        if not success then
            logMessage("error", "FFmpeg audio chunk extraction failed.")
             -- Attempting to map English audio track might fail if none exists.
             -- Check stderr for specific error. If it's the mapping error, try again without it.
             if err and type(err) == "string" and err:match("Stream map '0:a:m:language:eng' matches no streams") then
                 logMessage("warn", "English audio track not found, retrying extraction without language mapping.")
                 local retry_args = {
                     "-ss", tostring(start_ms / 1000),
                     "-t", tostring(duration_ms / 1000),
                     "-i", media_path,
                     "-map", "0:a:0", -- Map first audio stream optionally
                     "-ac", "1",
                     "-ar", "16000",
                     "-acodec", "pcm_s16le",
                     "-af", "aresample=resampler=soxr",
                     "-y", TMP_WAV_PATH
                 }
                 runCommand(FFMPEG_PATH, retry_args, "FFmpeg Chunk Extraction (Retry)", function(retry_output, retry_success, retry_err)
                    if not running then
                         logMessage("info", "Captioning stopped during FFmpeg chunk extraction retry.")
                         safeRemove(TMP_WAV_PATH, "Audio Chunk (Stopped during retry)")
                         callback(false)
                         return
                    end
                    if not retry_success then
                        logMessage("error", "FFmpeg audio chunk extraction retry failed.")
                        callback(false)
                        return
                    end
                    local file_info_retry = utils.file_info(TMP_WAV_PATH)
                    if not file_info_retry or not file_info_retry.size or file_info_retry.size == 0 then
                         logMessage("error", "FFmpeg retry reported success but output WAV file not found or is empty: " .. TMP_WAV_PATH)
                         callback(false)
                         return
                    end
                    logMessage("info", "Audio chunk extraction (retry) completed: " .. TMP_WAV_PATH)
                    callback(true)
                 end)
             else
                 callback(false) -- Original command failed for other reason
             end
             return
        end
        local file_info = utils.file_info(TMP_WAV_PATH)
        if not file_info or not file_info.size or file_info.size == 0 then
             logMessage("error", "FFmpeg reported success but output WAV file not found or is empty: " .. TMP_WAV_PATH)
             callback(false)
             return
        end
        logMessage("info", "Audio chunk extraction completed: " .. TMP_WAV_PATH)
        callback(true)
    end)
end

-- Main loop function to process the media sequentially in chunks (with VAD)
local function processNextChunk(media_path, total_duration_ms, current_start_time_ms)
    -- *** MODIFIED: Clear timer handle ***
    next_chunk_timer = nil

    if not running then
        logMessage("info", "Main loop: Halting processing as 'running' is false.")
        processing_chunk = false
        loopRunning = false
        return
    end
    if current_start_time_ms >= total_duration_ms then
        logMessage("info", "Main loop: Reached end of media.")
        running = false
        processing_chunk = false
        loopRunning = false
        mp.osd_message("Live caption finished.")
        return
    end
    if processing_chunk then
        logMessage("warn", "Main loop: Previous chunk still processing? Rescheduling check.")
        -- *** MODIFIED: Reschedule using timer ***
        next_chunk_timer = mp.add_timeout(1, function() processNextChunk(media_path, total_duration_ms, current_start_time_ms) end)
        return
    end

    processing_chunk = true
    local chunk_duration_ms = CHUNK_INTERVAL * 1000
    local remaining_time_ms = total_duration_ms - current_start_time_ms
    local actual_chunk_duration_ms = math.min(chunk_duration_ms, remaining_time_ms)

    -- Avoid processing tiny slivers at the end
    if actual_chunk_duration_ms < 1000 and current_start_time_ms > 0 then
         logMessage("info", "Main loop: Remaining duration (".. actual_chunk_duration_ms .."ms) too short, stopping.")
         running = false
         processing_chunk = false
         loopRunning = false
         mp.osd_message("Live caption finished (short remaining).")
         return
    end

    local next_start_time = current_start_time_ms + actual_chunk_duration_ms
    logMessage("debug", string.format("Processing chunk: %.3f -> %.3f (%.3f s)", current_start_time_ms / 1000, next_start_time / 1000, actual_chunk_duration_ms / 1000))

    -- 1. Extract Audio Chunk
    extractAudioChunk(media_path, current_start_time_ms, actual_chunk_duration_ms, function(extract_success)
        -- *** ADDED: Check running flag after extraction callback ***
        if not running then
            logMessage("info", "Processing stopped after audio extraction finished.")
            processing_chunk = false
            loopRunning = false
            safeRemove(TMP_WAV_PATH, "Audio Chunk (Stopped after extraction)")
            return
        end

        if not extract_success then
            logMessage("error", "Main loop: Failed to extract audio chunk. Scheduling next chunk check.")
            processing_chunk = false
            -- *** MODIFIED: Schedule next chunk using timer ***
            next_chunk_timer = mp.add_timeout(1, function() processNextChunk(media_path, total_duration_ms, next_start_time) end)
            return
        end

        -- 2. Run VAD on the extracted chunk
        runVAD(function(vad_success)
            -- *** ADDED: Check running flag after VAD callback ***
            if not running then
                logMessage("info", "Processing stopped after VAD finished.")
                processing_chunk = false
                loopRunning = false
                safeRemove(TMP_WAV_PATH, "Processed Audio Chunk (Stopped after VAD)")
                safeRemove(VAD_SEGMENTS_JSON_PATH, "VAD JSON (Stopped after VAD)")
                return
            end

            if not vad_success then
                logMessage("error", "Main loop: VAD failed. Scheduling next chunk check.")
                processing_chunk = false
                safeRemove(TMP_WAV_PATH, "Processed Audio Chunk (VAD Failed)")
                -- *** MODIFIED: Schedule next chunk using timer ***
                next_chunk_timer = mp.add_timeout(1, function() processNextChunk(media_path, total_duration_ms, next_start_time) end)
                return
            end

            -- 3. Process the segments identified by VAD
            processSegments(current_start_time_ms, function(segments_success)
                logMessage("info", "Main loop: Finished processing VAD segments for chunk starting at " .. current_start_time_ms .. " ms. Success: " .. tostring(segments_success))
                processing_chunk = false -- Mark chunk processing as complete *before* scheduling next

                safeRemove(TMP_WAV_PATH, "Processed Audio Chunk (Segments Done)")

                -- *** ADDED: Check running flag after segments callback ***
                if not running then
                     logMessage("info", "Main loop: Processing stopped after segments finished.")
                     loopRunning = false
                     return
                end

                logMessage("info", "Scheduling next chunk: Start= " .. next_start_time .. " ms")
                -- *** MODIFIED: Schedule next chunk using timer ***
                next_chunk_timer = mp.add_timeout(0, function() processNextChunk(media_path, total_duration_ms, next_start_time) end)
            end)
        end)
    end)
end


-- #########################################################################
-- # Control Functions                                                     #
-- #########################################################################

-- *** MODIFIED: Accept optional start time ***
local function start(start_offset_s)
    if running then
        logMessage("warn", "Start command ignored: Already running.")
        mp.osd_message("Live caption already running.")
        return
    end
    if loopRunning then
         logMessage("warn", "Start command ignored: Loop seems to be running? Forcing stop first.")
         -- Force reset state variables - Call the actual stop function first
         stop(true) -- Pass 'internal' flag to suppress OSD message
         -- Add a tiny delay to allow stop actions to settle before starting again
         mp.add_timeout(0.1, function() start(start_offset_s) end)
         return
    end

    logMessage("info", "Start function called." .. (start_offset_s and (" Seeking to " .. start_offset_s .. "s.") or ""))
    mp.osd_message("Starting live caption..." .. (start_offset_s and string.format(" (from %.1fs)", start_offset_s) or ""))

    local media_path = mp.get_property("path")
    local duration_s = mp.get_property_number("duration")

    if not media_path or not duration_s or duration_s <= 0 then
        logMessage("error", "Cannot start: No media loaded or duration is invalid.")
        mp.osd_message("Live caption failed: No media loaded?")
        return
    end
    local total_duration_ms = duration_s * 1000
    logMessage("info", "Media path: " .. media_path)
    logMessage("info", "Media duration: " .. duration_s .. " s (" .. total_duration_ms .. " ms)")

    -- Determine the actual start time in milliseconds
    local start_time_ms = 0
    if start_offset_s and start_offset_s > 0 then
        start_time_ms = math.floor(start_offset_s * 1000)
        if start_time_ms >= total_duration_ms then
             logMessage("warn", "Start time (" .. start_time_ms .. "ms) is beyond media duration (" .. total_duration_ms .. "ms). Starting from beginning.")
             start_time_ms = 0
             mp.osd_message("Live caption: Seek time beyond end, starting from beginning.")
        end
    end
    logMessage("info", "Captioning will start processing from " .. start_time_ms .. " ms.")


    -- Remove existing subtitle tracks
    logMessage("info", "Removing existing subtitle tracks before starting.")
    local track_list = mp.get_property_native("track-list")
    if track_list then
        for i = 1, #track_list do
            local track = track_list[i]
            if track.type == "sub" then
                logMessage("debug", "Removing existing subtitle track ID: " .. track.id)
                mp.commandv("sub_remove", track.id)
            end
        end
    else
        logMessage("warn", "Could not get track list to remove existing subtitles.")
    end

    -- Clear/Create the main SRT file
    local main_srt_file = io.open(MAIN_SRT_PATH, "w")
    if main_srt_file then
        main_srt_file:write("")
        main_srt_file:close()
        logMessage("info", "Cleared main subtitle file: " .. MAIN_SRT_PATH)

        -- Add the (empty) subtitle file initially with select flag
        local res = mp.commandv("sub_add", MAIN_SRT_PATH, "select")
        logMessage("info", "Initial subtitle track added. Result: " .. utils.to_string(res))
    else
        logMessage("error", "Failed to clear main subtitle file: " .. MAIN_SRT_PATH .. ". Cannot start.")
        mp.osd_message("Live caption failed: Cannot clear temp file.")
        return
    end

    -- Reset flags and start the processing loop
    running = true
    loopRunning = true
    processing_chunk = false
    VAD_running = false
    processing_segments = false
    next_chunk_timer = nil -- Ensure timers are nil initially
    segment_timer = nil
    seek_pending = false -- Ensure seek flag is reset

    logMessage("info", "Initiating first chunk processing from " .. start_time_ms .. " ms.")
    -- *** MODIFIED: Start processing using timer ***
    next_chunk_timer = mp.add_timeout(0, function() processNextChunk(media_path, total_duration_ms, start_time_ms) end)
end

-- *** MODIFIED: Added optional 'internal' flag to suppress OSD ***
local function stop(internal)
    if not running and not loopRunning and not seek_pending then
        logMessage("warn", "Stop command ignored: Not running or processing seek.")
        return
    end
    logMessage("info", "Stop function called.")
    if not internal then
        mp.osd_message("Stopping live caption...")
    end

    -- *** Critical: Set running flags false FIRST to prevent callbacks from proceeding ***
    running = false
    loopRunning = false -- Prevent new *loops* from starting

    -- *** Cancel pending timers ***
    if next_chunk_timer then
        mp.cancel_timer(next_chunk_timer)
        next_chunk_timer = nil
        logMessage("info", "Cancelled pending next chunk timer.")
    end
    if segment_timer then
        mp.cancel_timer(segment_timer)
        segment_timer = nil
        logMessage("info", "Cancelled pending segment processing timer.")
    end

    -- Reset state flags immediately
    processing_chunk = false
    VAD_running = false
    processing_segments = false
    -- Note: We don't reset seek_pending here, it's handled by the seek handler

    -- Add a short delay to allow state flags to propagate and potentially running subprocesses to notice
    mp.add_timeout(0.1, function()
        logMessage("info", "Performing cleanup after stop...")

        -- Clean up temporary files (subprocess output might still be written after this if they weren't killed)
        safeRemove(TMP_WAV_PATH, "Final Audio Chunk")
        safeRemove(VAD_SEGMENTS_JSON_PATH, "Final VAD JSON")
        -- More aggressive cleanup of potential segment files
        local pattern = "^(mpv_whisper_segment_%d+%.srt|segment_%d+_%d+%.wav|padded_.*segment_.*%.wav)$"
        local dir_handle = io.popen('dir "' .. TMP_DIR .. '" /b') -- Windows specific dir command
        if dir_handle then
            local files_removed = 0
            for filename in dir_handle:lines() do
                if filename:match(pattern) then
                    safeRemove(utils.join_path(TMP_DIR, filename), "Final Segment/Whisper Temp File")
                    files_removed = files_removed + 1
                end
            end
            dir_handle:close()
            logMessage("debug", "Removed " .. files_removed .. " leftover segment/whisper files.")
        else
             logMessage("warn", "Could not list directory for final temp file cleanup: " .. TMP_DIR)
        end

        logMessage("info", "Live caption stopped.")
        if not internal then
            mp.osd_message("Live caption stopped.")
        end
    end)
end

local function toggle()
    logMessage("info", "Toggle function called.")
    if running or loopRunning or seek_pending then
        stop()
    else
        -- *** MODIFIED: Start from current time-pos ***
        local current_pos = mp.get_property_number("time-pos")
        start(current_pos)
    end
end

-- *** ADDED: Seek handler function ***
local function handle_seek()
    if not running and not loopRunning then
        -- If not running, do nothing on seek
        return
    end

    if seek_pending then
        logMessage("info", "Seek event ignored: Already processing a previous seek.")
        return
    end

    logMessage("info", "Seek detected.")
    seek_pending = true -- Set flag to prevent race conditions

    -- Stop the current process immediately (internal call)
    stop(true)

    -- Use a timer to ensure stop() actions have initiated before starting again
    mp.add_timeout(0.2, function() -- Slightly longer delay for seek restart
        local new_pos = mp.get_property_number("time-pos")
        if new_pos == nil then
            logMessage("error", "Failed to get new time position after seek. Cannot restart.")
            seek_pending = false
            return
        end
        logMessage("info", "Restarting captioning after seek at " .. new_pos .. "s.")
        -- Start processing from the new position
        start(new_pos) -- This will reset seek_pending via the start->stop->start sequence if necessary, or reset it at the end of start()
    end)
end

-- #########################################################################
-- # MPV Integration                                                       #
-- #########################################################################

mp.add_key_binding("ctrl+w", "toggle_live_caption", toggle)
mp.add_key_binding("ctrl+alt+w", "stop_live_caption", function() stop() end) -- Ensure stop() is called without arguments

logMessage("info", "Whisper Live Caption (VAD + Seek Handling) script loaded. Press Ctrl+W to toggle.")

-- *** ADDED: Register seek event handler ***
-- Using 'playback-restart' might be slightly more robust as it covers seeks and loops
mp.register_event("playback-restart", handle_seek)
-- If 'playback-restart' doesn't catch all seeks reliably, you might fallback to "seek"
-- mp.register_event("seek", handle_seek)

mp.register_event("shutdown", function()
    logMessage("info", "MPV shutdown event: Stopping captioning and cleaning up.")
    stop(true) -- Internal stop on shutdown
end)

-- *** ADDED: Ensure cleanup on file load as well ***
mp.register_event("file-loaded", function()
    logMessage("info", "New file loaded. Stopping any previous captioning instance.")
    stop(true) -- Stop internally without OSD message if running from previous file
    -- Explicitly clear the main SRT path for the new file
    local main_srt_file = io.open(MAIN_SRT_PATH, "w")
    if main_srt_file then
        main_srt_file:write("")
        main_srt_file:close()
        logMessage("info", "Cleared main subtitle file for new media.")
    else
        logMessage("warn", "Could not clear main subtitle file on new file load: " .. MAIN_SRT_PATH)
    end
end)
